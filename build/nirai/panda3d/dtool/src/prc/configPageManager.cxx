// Filename: configPageManager.cxx
// Created by:  drose (15Oct04)
//
////////////////////////////////////////////////////////////////////
//
// PANDA 3D SOFTWARE
// Copyright (c) Carnegie Mellon University.  All rights reserved.
//
// All use of this software is subject to the terms of the revised BSD
// license.  You should have received a copy of this license along
// with this source code in a file named "LICENSE."
//
////////////////////////////////////////////////////////////////////

#include "configPageManager.h"
#include "configDeclaration.h"
#include "configVariableString.h"
#include "configPage.h"
#include "prcKeyRegistry.h"
#include "dSearchPath.h"
#include "executionEnvironment.h"
#include "config_prc.h"
#include "pfstream.h"
#include "pandaSystem.h"
#include "textEncoder.h"
#include "stringDecoder.h"

// This file is generated by ppremake.
#include "prc_parameters.h"

#include <set>

// Pick up the public key definitions.
#ifdef PRC_PUBLIC_KEYS_INCLUDE
#include PRC_PUBLIC_KEYS_INCLUDE
#endif

#include <algorithm>
#include <ctype.h>

ConfigPageManager *ConfigPageManager::_global_ptr = NULL;

////////////////////////////////////////////////////////////////////
//     Function: ConfigPageManager::Constructor
//       Access: Protected
//  Description: The constructor is private (actually, just protected,
//               but only to avoid a gcc compiler warning) because it
//               should not be explicitly constructed.  There is only
//               one ConfigPageManager, and it constructs itself.
////////////////////////////////////////////////////////////////////
ConfigPageManager::
ConfigPageManager() {
  _next_page_seq = 1;
  _loaded_implicit = false;
  _currently_loading = false;
  _pages_sorted = true;

#ifdef PRC_PUBLIC_KEYS_INCLUDE
  // Record the public keys in the registry at startup time.
  PrcKeyRegistry::get_global_ptr()->record_keys(prc_pubkeys, num_prc_pubkeys);
#endif  // PRC_PUBLIC_KEYS_INCLUDE
}

////////////////////////////////////////////////////////////////////
//     Function: ConfigPageManager::Destructor
//       Access: Protected
//  Description: The ConfigPageManager destructor should never be
//               called, because this is a global object that is never
//               freed.
////////////////////////////////////////////////////////////////////
ConfigPageManager::
~ConfigPageManager() {
  prc_cat->error()
    << "Internal error--ConfigPageManager destructor called!\n";
}

////////////////////////////////////////////////////////////////////
//     Function: ConfigPageManager::reload_implicit_pages
//       Access: Published
//  Description: Searches the PRC_DIR and/or PRC_PATH directories for
//               *.prc files and loads them in as pages.
//
//               This may be called after startup, to force the system
//               to re-read all of the implicit prc files.
////////////////////////////////////////////////////////////////////
void ConfigPageManager::
reload_implicit_pages() {
    // We don't want to load implicit pages on Nirai
}

////////////////////////////////////////////////////////////////////
//     Function: ConfigPageManager::make_explicit_page
//       Access: Published
//  Description: Creates and returns a new, empty ConfigPage.  This
//               page will be stacked on top of any pages that were
//               created before; it may shadow variable declarations
//               that are defined in previous pages.
////////////////////////////////////////////////////////////////////
ConfigPage *ConfigPageManager::
make_explicit_page(const string &name) {
  ConfigPage *page = new ConfigPage(name, false, _next_page_seq);
  ++_next_page_seq;
  _explicit_pages.push_back(page);
  _pages_sorted = false;
  invalidate_cache();
  return page;
}

////////////////////////////////////////////////////////////////////
//     Function: ConfigPageManager::delete_explicit_page
//       Access: Published
//  Description: Removes a previously-constructed ConfigPage from the
//               set of active pages, and deletes it.  The ConfigPage
//               object is no longer valid after this call.  Returns
//               true if the page is successfully deleted, or false if
//               it was unknown (which should never happen if the page
//               was legitimately constructed).
////////////////////////////////////////////////////////////////////
bool ConfigPageManager::
delete_explicit_page(ConfigPage *page) {
  Pages::iterator pi;
  for (pi = _explicit_pages.begin(); pi != _explicit_pages.end(); ++pi) {
    if ((*pi) == page) {
      _explicit_pages.erase(pi);
      delete page;
      invalidate_cache();
      return true;
    }
  }
  return false;
}

////////////////////////////////////////////////////////////////////
//     Function: ConfigPageManager::output
//       Access: Published
//  Description: 
////////////////////////////////////////////////////////////////////
void ConfigPageManager::
output(ostream &out) const {
  out << "ConfigPageManager, " 
      << _explicit_pages.size() + _implicit_pages.size() 
      << " pages.";
}

////////////////////////////////////////////////////////////////////
//     Function: ConfigPageManager::write
//       Access: Published
//  Description: 
////////////////////////////////////////////////////////////////////
void ConfigPageManager::
write(ostream &out) const {
  check_sort_pages();
  out << _explicit_pages.size() << " explicit pages:\n";

  Pages::const_iterator pi;
  for (pi = _explicit_pages.begin(); pi != _explicit_pages.end(); ++pi) {
    const ConfigPage *page = (*pi);
    out << "  " << page->get_name();
    if (page->get_trust_level() > 0) {
      out << "  (signed " << page->get_trust_level() << ": ";
      page->output_brief_signature(out);
      out << ")\n";
    } else if (!page->get_signature().empty()) {
      out << "  (invalid signature: ";
      page->output_brief_signature(out);
      out << ")\n";
    } else {
      out << "\n";
    }
  }

  out << "\n" << _implicit_pages.size() << " implicit pages:\n";
  for (pi = _implicit_pages.begin(); pi != _implicit_pages.end(); ++pi) {
    const ConfigPage *page = (*pi);
    out << "  " << page->get_name();
    if (page->get_trust_level() > 0) {
      out << "  (signed " << page->get_trust_level() << ": ";
      page->output_brief_signature(out);
      out << ")\n";
    } else if (!page->get_signature().empty()) {
      out << "  (invalid signature: ";
      page->output_brief_signature(out);
      out << ")\n";
    } else {
      out << "\n";
    }
  }
}

////////////////////////////////////////////////////////////////////
//     Function: ConfigPageManager::get_global_ptr
//       Access: Published
//  Description: 
////////////////////////////////////////////////////////////////////
ConfigPageManager *ConfigPageManager::
get_global_ptr() {
  if (_global_ptr == (ConfigPageManager *)NULL) {
    _global_ptr = new ConfigPageManager;
  }
  return _global_ptr;
}

// This class is used in sort_pages, below.
class CompareConfigPages {
public:
  bool operator () (const ConfigPage *a, const ConfigPage *b) const {
    return (*a) < (*b);
  }
};

////////////////////////////////////////////////////////////////////
//     Function: ConfigPageManager::sort_pages
//       Access: Private
//  Description: Sorts the list of pages into priority order,
//               so that the page at the front of the list is
//               the one that shadows all following pages.
////////////////////////////////////////////////////////////////////
void ConfigPageManager::
sort_pages() {
  sort(_implicit_pages.begin(), _implicit_pages.end(), CompareConfigPages());
  sort(_explicit_pages.begin(), _explicit_pages.end(), CompareConfigPages());

  _pages_sorted = true;
}

////////////////////////////////////////////////////////////////////
//     Function: ConfigPageManager::scan_auto_prc_dir
//       Access: Private
//  Description: Checks for the prefix "<auto>" in the value of the
//               $PRC_DIR environment variable (or in the compiled-in
//               DEFAULT_PRC_DIR value).  If it is found, then the
//               actual directory is determined by searching upward
//               from the executable's starting directory, or from the
//               current working directory, until at least one .prc
//               file is found.
//
//               Returns true if the prc_dir has been filled with a
//               valid directory name, false if no good directory name
//               was found.
////////////////////////////////////////////////////////////////////
bool ConfigPageManager::
scan_auto_prc_dir(Filename &prc_dir) const {
  string prc_dir_string = prc_dir;
  if (prc_dir_string.substr(0, 6) == "<auto>") {
    Filename suffix = prc_dir_string.substr(6);
    
    // Start at the dtool directory.
    Filename dtool = ExecutionEnvironment::get_dtool_name();
    Filename dir = dtool.get_dirname();

    if (scan_up_from(prc_dir, dir, suffix)) {
      return true;
    }
    
    // Try the program's directory.
    dir = ExecutionEnvironment::get_environment_variable("MAIN_DIR");
    if (scan_up_from(prc_dir, dir, suffix)) {
      return true;
    }

    // Didn't find it; too bad.
    cerr << "Warning: unable to auto-locate config files in directory named by \""
         << prc_dir << "\".\n";
    return false;
  }

  // The filename did not begin with "<auto>", so it stands unchanged.
  return true;
}

////////////////////////////////////////////////////////////////////
//     Function: ConfigPageManager::scan_up_from
//       Access: Private
//  Description: Used to implement scan_auto_prc_dir(), above, this
//               scans upward from the indicated directory name until
//               a directory is found that includes at least one .prc
//               file, or the root directory is reached.  
//
//               If a match is found, puts it result and returns true;
//               otherwise, returns false.
////////////////////////////////////////////////////////////////////
bool ConfigPageManager::
scan_up_from(Filename &result, const Filename &dir, 
             const Filename &suffix) const {
  Filename consider(dir, suffix);
  
  vector_string files;
  if (consider.is_directory()) {
    if (consider.scan_directory(files)) {
      vector_string::const_iterator fi;
      for (fi = files.begin(); fi != files.end(); ++fi) {
        Globs::const_iterator gi;
        for (gi = _prc_patterns.begin();
             gi != _prc_patterns.end();
             ++gi) {
          if ((*gi).matches(*fi)) {
            result = consider;
            return true;
          }
        }

        for (gi = _prc_executable_patterns.begin();
             gi != _prc_executable_patterns.end();
             ++gi) {
          if ((*gi).matches(*fi)) {
            result = consider;
            return true;
          }
        }
      }
    }
  }

  Filename parent = dir.get_dirname();

  if (dir == parent) {
    // Too bad; couldn't find a match.
    return false;
  }

  // Recursively try again on the parent.
  return scan_up_from(result, parent, suffix);
}

////////////////////////////////////////////////////////////////////
//     Function: ConfigPageManager::config_initialized
//       Access: Private
//  Description: This is called once, at startup, the first time that
//               the config system has been initialized and is ready
//               to read config variables.  It's intended to be a
//               place to initialize values that are defined at a
//               lower level than the config system itself.
////////////////////////////////////////////////////////////////////
void ConfigPageManager::
config_initialized() {
  Notify::ptr()->config_initialized();

#ifndef NDEBUG
  ConfigVariableString panda_package_version
    ("panda-package-version", "local_dev",
     PRC_DESC("This can be used to specify the value returned by "
              "PandaSystem::get_package_version_str(), in development mode only, "
              "and only if another value has not already been compiled in.  This "
              "is intended for developer convenience, to masquerade a development "
              "build of Panda as a different runtime version.  Use with caution."));
  ConfigVariableString panda_package_host_url
    ("panda-package-host-url", "",
     PRC_DESC("This can be used to specify the value returned by "
              "PandaSystem::get_package_host_url(), in development mode only, "
              "and only if another value has not already been compiled in.  This "
              "is intended for developer convenience, to masquerade a development "
              "build of Panda as a different runtime version.  Use with caution."));

  PandaSystem *panda_sys = PandaSystem::get_global_ptr();
  panda_sys->set_package_version_string(panda_package_version);
  panda_sys->set_package_host_url(panda_package_host_url);
#endif  // NDEBUG

  // Also set up some other low-level things.
  ConfigVariableEnum<TextEncoder::Encoding> text_encoding
    ("text-encoding", TextEncoder::E_utf8,
     PRC_DESC("Specifies how international characters are represented in strings "
              "of 8-byte characters presented to Panda.  See TextEncoder::set_encoding()."));
  TextEncoder::set_default_encoding(text_encoding);

  ConfigVariableEnum<TextEncoder::Encoding> filesystem_encoding
    ("filesystem-encoding", TextEncoder::E_utf8,
     PRC_DESC("Specifies the default encoding used for wide-character filenames."));
  Filename::set_filesystem_encoding(filesystem_encoding);

  StringDecoder::set_notify_ptr(&Notify::out());
}
